## Accepting Command Line Arguments
## Aceitando Argumentos em Linha de Comando

Let’s create a new project with, as always, `cargo new`. We’ll call our project
`minigrep` to distinguish it from the `grep` tool that you might already have
on your system.

Vamos criar um novo projeto usando, como sempre, `cargo new`. Chamaremos o nosso projeto
`minigrep` para distingui-lo da ferramenta` grep` que você já pode ter 
no seu sistema.

```text
$ cargo new --bin minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

The first task is to make `minigrep` accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with `cargo run`, a string to search for, and a path to a file to
search in, like so:

A primeira tarefa é fazer que `minigrep` aceite seus dois argumentos de linha de comando: o
nome de arquivo e uma string para procurar. Ou seja, queremos ser capazes de administrar o nosso
programa com `cargo run`, uma string para procurar e um caminho para um arquivo onde será feira a
procura, dessa forma:

```text
$ cargo run searchstring example-filename.txt
```

Right now, the program generated by `cargo new` cannot process arguments we
give it. However, some existing libraries on [Crates.io](https://crates.io/)
can help us with writing a program that accepts command line arguments, but
because you’re just learning this concept, let’s implement this capability
ourselves.

Neste momento, o programa gerado por `cargo new` não pode processar os argumentos que nós
passamos. No entanto, algumas bibliotecas existentes no [Crates.io](https://crates.io/)
que podem  nos ajudar a escrever um programa que aceite argumentos na linha de comando, mas
como você está aprendendo esses conceitos, vamos implementar essa capacidade
nós mesmos.

### Reading the Argument Values
### Lendo os Valores do Argumento

To make sure `minigrep` is able to read the values of command line arguments we
pass to it, we’ll need a function provided in Rust’s standard library, which is
`std::env::args`. This function returns an *iterator* of the command line
arguments that were given to `minigrep`. We haven’t discussed iterators yet
(we’ll cover them fully in Chapter 13), but for now you only need to know two
details about iterators: iterators produce a series of values, and we can call
the `collect` function on an iterator to turn it into a collection, such as a
vector, containing all the elements the iterator produces.

Para garantir que `minigrep` seja capaz de ler os valores dos argumentos da linha de comando, nós
precisamos de uma função fornecida na biblioteca padrão do Rust, que é
`std::env::args`. Esta função retorna um *iterador* da linha de comando
com os argumentos que foram passados à `minigrep`. Ainda não discutimos iteradores
(nós os cobrimos totalmente no Capítulo 13), mas por enquanto você só precisa saber dois
detalhes sobre iteradores: os iteradores produzem uma série de valores, e podemos chamar
a função `collect` em um iterador para transformá-lo em uma coleção, como um
vetor, contendo todos os elementos que o iterador produz.

Use the code in Listing 12-1 to allow your `minigrep` program to read any
command line arguments passed to it and then collect the values into a vector:

Use o código na Listagem 12-1 para permitir que seu programa `minigrep` leia qualquer
argumento da linha de comando passados para ele e depois colete os valores em um vetor:

<span class="filename">Filename: src/main.rs</span>

<span class="filename">Arquivo: src/main.rs</span>

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}
```

<span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span>

<span class="caption">Listagem 12-1: Coletando os argumentos da linha de comando
um vetor e imprimindo-os</span>

First, we bring the `std::env` module into scope with a `use` statement so we
can use its `args` function. Notice that the `std::env::args` function is
nested in two levels of modules. As we discussed in Chapter 7, in cases where
the desired function is nested in more than one module, it’s conventional to
bring the parent module into scope rather than the function. As a result, we
can easily use other functions from `std::env`. It’s also less ambiguous than
adding `use std::env::args` and then calling the function with just `args`
because `args` might easily be mistaken for a function that’s defined in the
current module.

Primeiro, trazemos o módulo `std::env` para o escopo com uma declaração `use`, então nós
podemos usar a função `args`. Observe que a função `std::env::args` é
aninhada em dois níveis de módulos. Como discutimos no Capítulo 7, nos casos em que
a função desejada está aninhada em mais de um módulo, é convenção
trazer o módulo pai para o escopo em vez da função. Como resultado, nós
podemos facilmente usar outras funções de `std::env`. Também é menos ambíguo que
adicionar `use std::env::args` e depois chamando a função com apenas `args`
porque `args` pode ser facilmente confundido com uma função definida no
módulo atual.

> ### The `args` Function and Invalid Unicode
>
> Note that `std::env::args` will panic if any argument contains invalid
> Unicode. If your program needs to accept arguments containing invalid
> Unicode, use `std::env::args_os` instead. That function returns `OsString`
> values instead of `String` values. We’ve chosen to use `std::env::args` here
> for simplicity because `OsString` values differ per platform and are more
> complex to work with than `String` values.

> ### A função `args` e Unicode Inválido
>
> Note que `std::env::args` emitirá pânico se algum argumento contiver código
> Unicode inválido. Se o seu programa precisar aceitar argumentos que sejam 
> Unicode inválidos , use `std::env::args_os` em vez disso. Essa função retorna valores `OsString`
> em vez de valores `String`. Nós escolhemos usar `std::env::args` aqui
> por simplicidade, porque os valores de `OsString` diferem por plataforma e são mais
> complexo para trabalhar do que os valores de `String`.

On the first line of `main`, we call `env::args`, and immediately use `collect`
to turn the iterator into a vector containing all the values produced by the
iterator. We can use the `collect` function to create many kinds of
collections, so we explicitly annotate the type of `args` to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, `collect` is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.

Na primeira linha do `main`, chamamos `env::args`, e usamos `collect` imediatamente
para transformar o iterador em um vetor contendo todos os valores produzidos pelo
iterador. Podemos usar a função `collect` para criar muitos tipos de
coleções, então nós explicitamente anotamos o tipo de `args` para especificar que nós
queremos um vetor de strings. Embora raramente precisemos anotar tipos em
Rust, `collect` é uma função que muitas vezes você precisa anotar, porque Rust
não é capaz de inferir o tipo de coleção que deseja.

Finally, we print the vector using the debug formatter, `:?`. Let’s try running
the code with no arguments, and then with two arguments:

Finalmente, imprimimos o vetor usando o formatador de debug, `:?`. Vamos tentar executar
o código sem argumentos e depois com dois argumentos:

```text
$ cargo run
--snip--
["target/debug/minigrep"]

$ cargo run needle haystack
--snip--
["target/debug/minigrep", "needle", "haystack"]
```

Notice that the first value in the vector is `"target/debug/minigrep"`, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case we want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.

Observe que o primeiro valor no vetor é `"target/debug/minigrep"`, que
é o nome do nosso binário. Isso corresponde ao comportamento da lista de argumentos em
C, permitindo que os programas usem o nome pelo qual eles foram invocados em sua execução.
Geralmente, é conveniente ter acesso ao nome do programa, caso desejemos imprimi-lo em mensagens ou 
alterar o comportamento do programa com base no alias da linha de comando que foi usado 
para chamar o programa. Mas, para os fins deste capítulo, vamos ignorá-lo e salvar apenas 
os dois argumentos que precisamos.

### Saving the Argument Values in Variables
### Salvando os Valores do Argumento em Variáveis

Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2:

Imprimir o valor do vetor de argumentos ilustra que o programa é
capaz de acessar os valores especificados como argumentos da linha de comando. Agora precisamos
salvar os valores dos dois argumentos nas variáveis para que possamos usar esses valores
durante o resto do programa. Fazemos isso na Listagem 12-2:

<span class="filename">Filename: src/main.rs</span>

<span class="filename">Arquivo: src/main.rs</span>

```rust,should_panic
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let filename = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", filename);
}
```

<span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span>

<span class="caption">Listagem 12-2: Criando variáveis para guardar o argumento de consulta
e argumento do nome do arquivo</span>

As we saw when we printed the vector, the program’s name takes up the first
value in the vector at `args[0]`, so we’re starting at index `1`. The first
argument `minigrep` takes is the string we’re searching for, so we put a
reference to the first argument in the variable `query`. The second argument
will be the filename, so we put a reference to the second argument in the
variable `filename`.

Como vimos quando imprimimos o vetor, o nome do programa ocupa o primeiro
valor no vetor em `args[0]`, então estamos começando no índice `1`. O primeiro
argumento `minigrep` é a string que estamos procurando, então colocamos uma
referência ao primeiro argumento na variável `query`. O segundo argumento
será o nome do arquivo, então colocamos uma referência ao segundo argumento no
variável `filename`.

We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments `test`
and `sample.txt`:

Imprimimos temporariamente os valores dessas variáveis para provar que o código funciona
como pretendemos. Vamos executar este programa novamente com os argumentos `test`
e `sample.txt`:

```text
$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
```

Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file reading
capabilities instead.

Ótimo, o programa está funcionando! Os valores dos argumentos que precisamos estão sendo
salvos nas variáveis certas. Mais tarde, adicionaremos algum tratamento de erro para lidar
com certas situações errôneas potenciais, como quando o usuário não fornece
argumentos; por enquanto, ignoraremos essa situação, e trabalharemos na adição das 
funcinalidades de leitura dos arquivos.